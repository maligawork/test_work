# Test Project

## 1. Installation
```
git clone https://github.com/maligawork/test_work.git
cd test_work
```

## 2. Setup Environment Conda
```
conda env create -f environment.yml
```

## 3. Run training code

Run training:
```
cd bin
python train.py
```

Resume training:
```
python train.py --experimental-rerun path-to-config.pickle-file
```

## 4. Run test code

Download test_experiments.zip and unzip it in the root directory.
https://drive.google.com/file/d/1yx2Gbo8zDjy0ZI59zPPZO1Vod6XGRsRu/view?usp=share_link

Run inference:
```
cd bin
python test.py
```


# Решение п.2 задания

Как объединить информацию с двух изображений в архитектуре модели?

### 1. Конкатенация по каналам
Просто объединяем два изображения по каналам.
#### Преимущества:
- Простота реализации (хорошо подходит для baseline модели)
- Можно использовать стандартные архитектуры CNN без модификаций
#### Недостатки:
- Не учитывает, что изображения связаны (модель просто видит два отдельных изображения)
- Может приводить к проблемам с памятью при использовании больших изображений

### 2. Использовать ViT архитектуру
Каждое изображение разбивается на патчи -> объединяем патчи обоих изображений в один общий набор -> получаем эмбединги -> подаем на вход ViT модели -> используем CLS-токен для предсказания.
#### Преимущества:
- Модель может находить сложные зависимости между изображениями
- Учитывает расположение объектов на изображении (что может быть проблемой в п.1)
#### Недостатки:
- Требует больше данных и ресурсов для обучения (в нашем случае это не большая проблема)
- Будет работать медленнее, чем CNN и иметь много параметров

### 3. Использовать сиамскую архитектуру
Используем две идентичные ветви (с одинаковыми весами)-> извлекаем признаки из обоих изображений -> сравниваем признаки -> предсказываем.
#### Преимущества:
- Эффективно используется информация из обоих изображений
- Сеть учится отличать изображения друг от друга, а не просто классифицировать их как в п.1
- Можно использовать предобученные архитектуры CNN для извлечения признаков, а не учить с нуля
- Меньше параметров и операций в модели по сравнению с п.2 (можно конечно взять ViT в качестве backbone, но это излишне)
#### Недостатки:
- Реализация чуть сложнее, чем в п.1


